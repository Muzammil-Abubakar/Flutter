First we import material.dart

then we run void main and inside void main we have runapp which is our entry point

inside our runapp we have to give a widget that flutter will render. 

for that we can use custom widget by using class and then extending after that we have to override the build method. 

we can also just use a pre built class such as materialApp which is a class that gives us some basic good looking things provided by google.

inside material app in home attribute/property: we can also use a scaffold, why? i forgot


in scaffold we have appbar property, and many others.


But doing this without build and overriding will not us see the changes without hot reload. The reason we use stateless widgets and custom classes is to see the changes immediately after saving the file as it automatically hot reloads for us.

the buildcontext context is a something that is required to be passed around sometimes to differnt widgets or functions

Now we can even pass Home class into the body of scaffold.

Then comes the container widget, very much like a div it helps us in managing our content through padding margins and etc 

By default container hogs all the space if there is no child

padding and margin usually come inside container. and use edgeinsets all

To change the text style properties, we can use style in the style tab


The refactoring in Flutter is so clean omg. You can just move it out somewhere else.

Column widget can have multiple children that is why we can use a children array for that.

Column will try shift all elements so all the largest width elements start from left most and small width element shift to the right to keep aligned.

main axis and cross axis means row and column on the type of group.

stretching the axis, overrides the values.

Ok so row and column are super super super fun ngl broskis

we can give assets path through pubsec.yaml

so changing assets or other main folders can cause issues which can be fixed by running flutter clean, flutter pub get and flutter run

In case of overflowing widget, we can use expanded widget, then we can use alignment with alignment geometry and fit with boxfit

expanded helps the element take all the available space, so incase of herizontal text element after sized box in expanded, it will take up all available space first then place the text at the end, on the right side


Best button is the filled button, for styling we have the filledbutton.stylefrom attribute which feels really good to use, we get foreground and background options. Also we have to put child in the last, as it is a convention and it may break the code sometimes.

Stateless widget can be easily converted to stateful widget by your ide. Also you need to use setstate in the functions where you are wanting to update the state otherwise the app will not rebuild.

you dont need curly braces in for loop as for loop is being applied on each seperate child so just place it according to the comma.


When making custom widgets, we make a class for them and then put them into the parameter in the class constructor and also initialize a final variable that will store that value.

This is honestly so fun, i love this so muchhhhh.


Funnnnnn thingggg, ommgggg soooo funnnnnn.

For parameters that are necessary, we use required keyword. Also we have to make sure that after the constructor, the type of the class mtches the parameters that we will be giving to the class. For example void Function(), for a function, final Widget() for a widget etc.

In the class const body, the parameters in the culry braces must always be provided and they cannot be left empty.  

So now i started another video and that guy told a very fun thing, that flutter is widget inside widget, but to put a widget inside a widget you first need tot give an arguement inside that first widget.

The main data types in flutter/ dart are: String, int, double, List, Map where map is basically the equivalent of Dictionaries, you initialize a map by putting curly braces {}. Also you can give strong type map and list so you dont put any weird value inside of them.

In dart, dynamic is used for a type that can contain all the types.

we can use double.infinity for spreading the code. Body center was to start the code of the body from the center.

By default MaterialApp provides us with some themes, For example if we make a filledButton, it will have a Purple color, who decided that and can we change that etc, for these things we will use themes.

Similarly, stuff like text size and font etc, and appbar and body color are also defined by these default themes.

For setting theme we just create a new dart file and create a new file inside it.

Refresher: Static fields of a class are properties of a class that can be accessed directly without making an instance of the class.

so in case of colors , just make a color variable and provide it with a color value.

This was just to easily access custom colors that we have decided upon. After that we need to create a theme data object.

So in themedata we have to give colorScheme with attribute from seed; incase we dont want to specify each color of the theme by ourselves. 

after that we let the seed be the primary color of our AppColor.

Then we put that theme into the main entry point below the materialApp

Within themeData, we can also change stuff like scaffold color, appbarTheme and etc.

He didnt tell much about the surfaceTintColor, saying it would become apparent in the future videos.

Now we are working on the textTheme, and so the TextTheme takes some textstyls for some specific sizes.

We can also use copywith, it helps us in creating a copy with something by keeping the defaults as it is but changing the others to custom ones we set.


Ok so now he also teaches us how to use context in build widget, we have to use themeof and then theme type and then subtype/attribute

Again theme was given while calling the materialApp first through the runApp function, then maybe it saves it in context.

Ok So genius thing is to make theme, and then make some classes for that theme in a shared dir in lib and creating a dartFile called styled_text etc. This will help in 1. making code reusable and needing to change only at one place, 2 removing redudancy of verbose introduced by 1.

We can install Google Fonts through pub install and finding the package for that.

The method and imports for every package can be found in the docuementation of that package.

As for gradients, we cannot directly apply gradients in flutter to a button, although we can create gradient fill for container widget

For gradients, we have to decoration property and provide it with Box Decoration class.

then we have to give colors and tell it from where to start and where to end. using (begin) and (end)

For outputting dynamic view of something we should use a list view widget. For using list view widget, we first need a list view builder

in the list view builder we need item count and item builder, where item count is runs for character length and item Biuilder is the function that willl build each list  item according to that function

in the item builder function we will give context or nothing if context is not being used, and then we pass in index which we will be using for index specific things, it hold the reference to item number. after that is our function body.

List view wil cause you constraints problems because we do not know the length or height that this can achieve, so flutter will give us an error and ask us to constraint this before proceeding. For this we can use Expanded widget like before.

Ok so theme such as CardTheme means, where to apply the color, and theme data e.g CardThemeData tells us how the theme should look like

So now we are making our first Class, we make required fields and then final variables to store them, also a bool variable that is assigned a value of false.

we also make a togglefunction that toggles our favorites.

mixin is a collection of fields and methods that can then be used by other classes. They provide a way for different classes to share certain properties amongst each other.

when we want to use a mixin, we add an "with" infront of class name.

In case of getters, we use a getter function, the syntax is get var => _var;. You can also specify a type in the start

something cool that i learned is that we can make a really cool list of maps as well, though i do not yet know how it will be used in other future stuff but hey atleast it looks really cool.

As for enhanced enums. we can create one and its just like making a class, we give it construction arguements and then define those arguements, we will make identifiers for that enum by using the constructor and putting in required values in them.

So up until now we have, stats mixin and vocation enhanced enum and some properties of itself as well. now we need a skill fields, and for that we need a skill object that contains those skills, for this we will make a class

In the character class, the skill field will be a set of skill objects

If we use a Set in a final, we can still update the values of that final variable through getter setters, although we cannot reassign to something else.

When adding assets in the pubsec.yaml we dont really need to add the path to each image, we can just give the parent folder to that image.


Right now we have dummy data which is showing the characters that we have, but we want to have the option of adding custom characters, for that we are making a create screen, with the dart file called create.dart

For getting text from the user, there is a built in field in flutter called Text Field. In Text field, we have some text decorations, and Input decroations that let us add an prefix icon and also for adding a label

We can also edit the input decoration fields in theme file, but not textfield directly


for storing the text, we can use text editing controller, or the unchanged callback function or similar

disposing text editing controllers, or similar variables that are used to store values but those values are not needed after the widget is removed from the scene tree. We can do that by using disponse function. the controller goes into the textField widget.

So for the handling of text field, we are making a button handler that will check the state of the Text Controllers when the button is clicked, if the fields are empty then it will give an error, otherwise it will print the text for us

After that we just called Vocation Card and displayed the different vocation which ngl looks really cool.

For overflowing, we can just use SingleChildScrollView widget which makes the page scrollable for us.

For detecting gestures like a tap on the vocation card, we can use a Gesture Detector widget something something blah blah.

Ok so we first need a selected default state, that can be assigned within a variable and given the Vocationjunkie enum. Then for updating the vocation, we will make a function that will take in a vocation and use setState for doing a rebuild.

When we are making a function for a construction and that function has arguements, we have to pass those arguements into the Function() brackets not identifier.

then for toggle function we can use a ternary operator, really fun to do. Also we can check if the state is selected by comparing it to selected state. 
The selected state is being updated when any onTap is called.

in the ontap attribute of gesture detector, we have to give in the funciton we want to call within (){ here }

uuid package is a package which helps us generate random id's

To route inbetween screens, we use the navigator class, it works on a push and pop basis. or it can work on a replacement basis.

The navigator class needs access to a context arguement, then we give MaterialPageRoute which takes builder and it takes context (called ctx for ease) then we go to the page we want to go to, remember flutter is rebuilding with udpated data each time which is so goat.

Now we will be showing dialogue in case the person does not fill the form correctly. For that we will use showDialog function, it also takes in context, builder, inside the builder we can use alertDialog or Alert Dialog.

within the Alert Dialog, we can style its colors and whatnot and also we can align the action property within it, through using mainAxisAlignment.

for closing the dialgog, we will use the navigator class as flutter uses the dialog as some kind of route. For the context, we have to give ctx not the main context.

also we can change bg color and surfacetint color

Now we will be passing data into routes.